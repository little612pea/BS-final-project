import entities.Product;
import entities.Borrow;
import entities.Card;
import org.apache.commons.lang3.RandomUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import queries.*;
import utils.ConnectConfig;
import utils.DatabaseConnector;
import utils.RandomData;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class LibraryTest {

    private DatabaseConnector connector;
    private LibraryManagementSystem library;

    private static ConnectConfig connectConfig = null;

    static {
        try {
            // parse connection config from "resources/application.yaml"
            connectConfig = new ConnectConfig();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    public LibraryTest() {
        try {
            // connect to database
            connector = new DatabaseConnector(connectConfig);
            library = new LibraryManagementSystemImpl(connector);
            System.out.println("Successfully init class ProductTest.");
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    @Before
    public void prepareTest() {
        boolean connStatus = connector.connect();
        Assert.assertTrue(connStatus);
        System.out.println("Successfully connect to database.");
        ApiResult result = library.resetDatabase();
        if (!result.ok) {
            System.out.printf("Failed to reset database, reason: %s\n", result.message);
            Assert.fail();
        }
        System.out.println("Successfully reset database.");
    }

    @After
    public void afterTest() {
        boolean releaseStatus = connector.release();
        if (releaseStatus) {
            System.out.println("Successfully release database connection.");
        } else {
            System.out.println("Failed to release database connection.");
        }
    }

    @Test
    public void productRegisterTest() {
        Product b0 = new Product("Computer Science", "Database System Concepts",
                "Machine Industry Press", "2023", "Mike", 188.88, 10);
        Assert.assertTrue(library.storeProduct(b0).ok);
        /* Not allowed to create duplicated records */
        Product b1 = new Product("Computer Science", "Database System Concepts",
                "Machine Industry Press", "2024", "Mike", 188.88, 5);
        Product b2 = new Product("Computer Science", "Database System Concepts",
                "Machine Industry Press", "2023", "Mike", 99.99, 10);
        Assert.assertFalse(library.storeProduct(b1).ok);
        Assert.assertFalse(library.storeProduct(b2).ok);
        /* check equal function */
        // records all products generated by test case, include duplicate products.
        List<Product> originProductList = new ArrayList<Product>() {{
            add(b0);
            add(b1);
            add(b2);
        }};
        // records which products should exist in database
        Set<Product> actualProductList = new HashSet<Product>() {{
            add(b0); // b0 already inserted to database
        }};
        // corresponding to originProductList, mark whether a product is duplicated
        List<Boolean> productValid = new ArrayList<Boolean>() {{
            // b0 already inserted to database, so productValid[0] is false
            add(false);
            add(false);
            add(false);
        }};
        for (int i = 0; i < originProductList.size(); i++) {
            if (actualProductList.contains(originProductList.get(i))) {
                Assert.assertFalse(productValid.get(i));
            } else {
                actualProductList.add(originProductList.get(i));
                Assert.assertTrue(productValid.get(i));
            }
        }
        Assert.assertEquals(1, actualProductList.size());
        /* generate some products */
        for (int i = 0; i < 50; i++) {
            Product b = RandomData.randomProduct();
            originProductList.add(b);
            if (actualProductList.contains(b)) {
                productValid.add(false);
            } else {
                actualProductList.add(b);
                productValid.add(true);
            }
        }
        Assert.assertEquals(originProductList.size(), productValid.size());
        Assert.assertTrue(originProductList.size() > actualProductList.size());
        /* generate some duplicate products */
        for (int i = 0; i < 10; i++) {
            int dupIndex = RandomUtils.nextInt(0, originProductList.size());
            Product ob = originProductList.get(dupIndex);
            if (productValid.get(i)) {
                Assert.assertTrue(actualProductList.contains(ob));
                Product cb = ob.clone();
                // randomly change some attributes
                if (RandomUtils.nextBoolean()) {
                    cb.setSource(RandomData.randomStock());
                    cb.setPrice(RandomData.randomPrice());
                }
                Assert.assertTrue(actualProductList.contains(cb));
                originProductList.add(cb);
                productValid.add(false);
            }
        }
        Assert.assertEquals(originProductList.size(), productValid.size());
        Assert.assertTrue(originProductList.size() > actualProductList.size());
        /* bulk load these products */
        for (int i = 0; i < originProductList.size(); i++) {
            Product product = originProductList.get(i);
            if (productValid.get(i)) {
                Assert.assertTrue(library.storeProduct(product).ok);
            } else {
                Assert.assertFalse(library.storeProduct(product).ok);
            }
        }
        /* use query interface to check correctness */
        ApiResult queryResult = library.queryProduct(new ProductQueryConditions());
        Assert.assertTrue(queryResult.ok);
        // parse query results from payload
        ProductQueryResults selectedResults = (ProductQueryResults) queryResult.payload;
        Assert.assertEquals(selectedResults.getCount(), selectedResults.getResults().size());
        // sort actual product list by its PK
        List<Product> compareProducts = new ArrayList<>(actualProductList);
        compareProducts.sort(Comparator.comparingInt(Product::getProductId));
        Assert.assertEquals(compareProducts.size(), selectedResults.getCount());
        for (int i = 0; i < compareProducts.size(); i++) {
            Product o1 = compareProducts.get(i);
            Product o2 = selectedResults.getResults().get(i);
            Assert.assertEquals(o1.toString(), o2.toString());
        }
    }

    @Test
    public void incProductStockTest() {
        /* simply insert some products to database */
        Set<Product> productSet = new HashSet<>();
        Set<Integer> productIds = new HashSet<>();
        for (int i = 0; i < 50; i++) {
            productSet.add(RandomData.randomProduct());
        }
        for (Product product : productSet) {
            Assert.assertTrue(library.storeProduct(product).ok);
            productIds.add(product.getProductId());
        }
        Assert.assertEquals(productSet.size(), productIds.size());
        /* corner case: invalid product id */
        Assert.assertFalse(library.incProductStock(-1, 6).ok);
        int k = productSet.size() + 1;
        while (productIds.contains(k)) {
            ++k;
        }
        Assert.assertFalse(library.incProductStock(k, 10).ok);
        /* corner case: invalid product source */
        List<Product> productList = new ArrayList<>(productSet);
        Product b0 = productList.get(0);
        Assert.assertTrue(library.incProductStock(b0.getProductId(), -b0.getSource()).ok); // source = 0
        Assert.assertTrue(library.incProductStock(b0.getProductId(), 1).ok);  // source = 1
        Assert.assertFalse(library.incProductStock(b0.getProductId(), -2).ok); // source = -1
        b0.setSource(1);
        /* randomly choose some products to do this operation */
        int nOps = 1000;
        for (int i = 0; i < nOps; i++) {
            Product product = productList.get(new Random().nextInt(productList.size()));
            int deltaStock = RandomUtils.nextInt(0, 24) - 8;
            if (product.getSource() + deltaStock >= 0) {
                Assert.assertTrue(library.incProductStock(product.getProductId(), deltaStock).ok);
                product.setSource(product.getSource() + deltaStock);
            } else {
                Assert.assertFalse(library.incProductStock(product.getProductId(), deltaStock).ok);
            }
        }
        /* use query interface to check correctness */
        productList.sort(Comparator.comparingInt(Product::getProductId));
        ApiResult queryResult = library.queryProduct(new ProductQueryConditions());
        Assert.assertTrue(queryResult.ok);
        ProductQueryResults selectedResults = (ProductQueryResults) queryResult.payload;
        for (int i = 0; i < productList.size(); i++) {
            Product o1 = productList.get(i);
            Product o2 = selectedResults.getResults().get(i);
            Assert.assertEquals(o1.toString(), o2.toString());
        }
    }

    @Test
    public void bulkRegisterProductTest() {
        /* simply insert some products to database */
        int nOps = 1000;
        Set<Product> productSet = new HashSet<>();
        for (int i = 0; i < nOps; i++) {
            productSet.add(RandomData.randomProduct());
        }
        /* provide some duplicate records */
        List<Product> productList1 = new ArrayList<>(productSet);
        for (int i = 0; i < 3; i++) {
            Product cb = productList1.get(new Random().nextInt(productList1.size())).clone();
            // randomly change some attributes
            if (RandomUtils.nextBoolean()) {
                cb.setSource(RandomUtils.nextInt(0, 20));
                cb.setPrice(RandomUtils.nextDouble(6.66, 233.33));
            }
            productList1.add(cb);
        }
        Collections.shuffle(productList1);
        Assert.assertFalse(library.storeProduct(productList1).ok);
        /* make sure that none of the products are inserted */
        ApiResult queryResult1 = library.queryProduct(new ProductQueryConditions());
        Assert.assertTrue(queryResult1.ok);
        ProductQueryResults selectedResults1 = (ProductQueryResults) queryResult1.payload;
        Assert.assertEquals(0, selectedResults1.getCount());
        /* normal batch insert */
        List<Product> productList2 = new ArrayList<>(productSet);
        Assert.assertTrue(library.storeProduct(productList2).ok);
        ApiResult queryResult2 = library.queryProduct(new ProductQueryConditions());
        Assert.assertTrue(queryResult2.ok);
        ProductQueryResults selectedResults2 = (ProductQueryResults) queryResult2.payload;
        Assert.assertEquals(productList2.size(), selectedResults2.getCount());
        productList2.sort(Comparator.comparingInt(Product::getProductId));
        for (int i = 0; i < productList2.size(); i++) {
            Product o1 = productList2.get(i);
            Product o2 = selectedResults2.getResults().get(i);
            Assert.assertEquals(o1.toString(), o2.toString());
        }
    }

    @Test
    public void removeProductTest() {
        /* simply insert some data to database */
        MyLibrary my = MyLibrary.createLibrary(library, 100, 1, 0);
        /* remove a non-exist product */
        Assert.assertFalse(library.removeProduct(-1).ok);
        /* remove a product that someone has not returned yet */
        Borrow borrow = new Borrow(my.products.get(0), my.cards.get(0));
        borrow.resetBorrowTime();
        Assert.assertTrue(library.borrowProduct(borrow).ok);
        Assert.assertFalse(library.removeProduct(my.products.get(0).getProductId()).ok);
        borrow.resetReturnTime();
        Assert.assertTrue(library.returnProduct(borrow).ok);
        Assert.assertTrue(library.removeProduct(my.products.get(0).getProductId()).ok);
        /* remove a non-exist product */
        Assert.assertFalse(library.removeProduct(my.products.get(0).getProductId()).ok);
        my.products.remove(0);
        /* randomly choose nRemove products to remove */
        int nRemove = RandomUtils.nextInt(10, 50);
        Collections.shuffle(my.products);
        for (int i = 0; i < nRemove; i++) {
            Assert.assertTrue(library.removeProduct(my.products.get(0).getProductId()).ok);
            /* remove a non-exist product */
            Assert.assertFalse(library.removeProduct(my.products.get(0).getProductId()).ok);
            my.products.remove(0);
        }
        /* compare results */
        ApiResult queryResult1 = library.queryProduct(new ProductQueryConditions());
        Assert.assertTrue(queryResult1.ok);
        ProductQueryResults selectedResults1 = (ProductQueryResults) queryResult1.payload;
        Assert.assertEquals(my.products.size(), selectedResults1.getCount());
        my.products.sort(Comparator.comparingInt(Product::getProductId));
        for (int i = 0; i < my.products.size(); i++) {
            Product o1 = my.products.get(i);
            Product o2 = selectedResults1.getResults().get(i);
            Assert.assertEquals(o1.toString(), o2.toString());
        }
    }

    @Test
    public void modifyProductTest() {
        /* simply insert some products to database */
        Set<Product> productSet = new HashSet<>();
        for (int i = 0; i < 100; i++) {
            productSet.add(RandomData.randomProduct());
        }
        List<Product> productList = new ArrayList<>(productSet);
        for (Product product : productList) {
            Assert.assertTrue(library.storeProduct(product).ok);
        }
        /* randomly change products */
        for (Product product : productList) {
            // remove old product from product set
            Assert.assertTrue(productSet.remove(product));
            int oldStock = product.getSource(); // product's source cannot be changed by modifyProductInfo
            do {  // make sure the new product does not exist in database
                // use bit mask to determine which field to update
                int mask = RandomUtils.nextInt(0, 128);
                if ((mask & 1) > 0) {
                    product.setComment(RandomData.randomCategory());
                }
                if ((mask & 2) > 0) {
                    product.setTitle(RandomData.randomTitle());
                }
                if ((mask & 4) > 0) {
                    product.setShop(RandomData.randomPress());
                }
                if ((mask & 8) > 0) {
                    product.setDeal(RandomData.randomPublishYear());
                }
                if ((mask & 16) > 0) {
                    product.setImg(RandomData.randomAuthor());
                }
                if ((mask & 32) > 0) {
                    product.setPrice(RandomData.randomPrice());
                }
                if ((mask & 64) > 0) {
                    product.setSource(RandomData.randomStock());
                }
            } while (productSet.contains(product));
            // insert new product to product set
            productSet.add(product);
            Assert.assertTrue(library.modifyProductInfo(product).ok);
            product.setSource(oldStock);
        }
        /* compare results */
        ApiResult queryResult = library.queryProduct(new ProductQueryConditions());
        Assert.assertTrue(queryResult.ok);
        ProductQueryResults selectedResults = (ProductQueryResults) queryResult.payload;
        Assert.assertEquals(productList.size(), selectedResults.getCount());
        productList = new ArrayList<>(productSet);
        productList.sort(Comparator.comparingInt(Product::getProductId));
        for (int i = 0; i < productList.size(); i++) {
            Product o1 = productList.get(i);
            Product o2 = selectedResults.getResults().get(i);
            Assert.assertEquals(o1.toString(), o2.toString());
        }
    }

    @Test
    public void queryProductTest() {
        /* simply insert some products to database */
        MyLibrary my = MyLibrary.createLibrary(library, 1000, 0, 0);
        /* generate single query condition */
        List<ProductQueryConditions> queryConditions = new ArrayList<>();
        for (int i = 0; i < 15; i++) {
            queryConditions.add(new ProductQueryConditions());
        }
        queryConditions.get(0).setComment(RandomData.randomCategory());
        queryConditions.get(1).setTitle(RandomData.randomTitle());
        queryConditions.get(2).setShop("Press");   // test fuzzy matching
        queryConditions.get(3).setShop(RandomData.randomPress());
        queryConditions.get(4).setMinPrice(RandomData.randomPrice());
        queryConditions.get(5).setMaxPrice(RandomData.randomPrice());
        queryConditions.get(6).setMinPrice(20.23);
        queryConditions.get(6).setMaxPrice(52.42);
        queryConditions.get(7).setMinPublishYear(2008);
        queryConditions.get(8).setMaxPublishYear(2020);
        {
            int minY = RandomUtils.nextInt(2000, 2015);
            int maxY = Math.max(RandomUtils.nextInt(2007, 2024), minY);
            queryConditions.get(9).setMinPublishYear(minY);
            queryConditions.get(9).setMaxPublishYear(maxY);
        }
        queryConditions.get(10).setImg("o");   // test fuzzy matching
        queryConditions.get(11).setImg(RandomData.randomAuthor());
        queryConditions.get(12).setSortBy(Product.SortColumn.PRICE);
        queryConditions.get(12).setSortOrder(SortOrder.ASC);
        queryConditions.get(13).setSortBy(Product.SortColumn.PRICE);
        queryConditions.get(13).setSortOrder(SortOrder.DESC);
        queryConditions.get(14).setSortBy(Product.SortColumn.PUBLISH_YEAR);
        queryConditions.get(14).setSortOrder(SortOrder.DESC);
        /* generate multi query conditions */
        for (int i = 0; i < 32; i++) {
            ProductQueryConditions c = new ProductQueryConditions();
            int mask = i;
            int selected = 0;
            if ((mask & 1) > 0) {
                c.setShop(RandomData.randomPress());
                selected++;
            }
            if ((mask & 2) > 0) {
                c.setComment(RandomData.randomCategory());
                selected++;
            }
            if ((mask & 4) > 0) {
                c.setImg(RandomData.randomAuthor());
                selected++;
            }
            // randomly select year
            if (RandomUtils.nextInt(1, 2 + selected) == 1) {
                int minY = RandomUtils.nextInt(2000, 2015);
                int maxY = Math.max(RandomUtils.nextInt(2007, 2024), minY + 7);
                c.setMinPublishYear(minY);
                c.setMaxPublishYear(maxY);
                selected++;
            }
            // randomly select price
            if (RandomUtils.nextInt(1, 3 + selected) == 1) {
                double minP = RandomData.randomPrice();
                double maxP = Math.max(RandomData.randomPrice(), minP + 16.66);
                c.setMinPrice(minP);
                c.setMaxPrice(maxP);
            }
            // randomly choose one column to sort
            if (RandomUtils.nextInt(1, 4) != 1) {
                c.setSortBy(Product.SortColumn.random());
                c.setSortOrder(SortOrder.random());
            }
            queryConditions.add(c);
        }
        /* loop testing */
        int iter=0;
        for (ProductQueryConditions queryCondition : queryConditions) {
            System.out.printf("%d\n",iter);
            iter=iter+1;
            ApiResult queryResult = library.queryProduct(queryCondition);
            Assert.assertTrue(queryResult.ok);
            ProductQueryResults productResults = (ProductQueryResults) queryResult.payload;
            List<Product> expectedResults = verifyQueryResult(my.products, queryCondition);
            Assert.assertEquals(expectedResults.size(), productResults.getCount());
            for (int i = 0; i < expectedResults.size(); i++) {
                Product o1 = expectedResults.get(i);
                Product o2 = productResults.getResults().get(i);
                Assert.assertEquals(o1.toString(), o2.toString());
            }
        }
    }

    @Test
    public void borrowAndReturnProductTest() {
        /* insert some products & cards & borrow histories to database */
        MyLibrary my = MyLibrary.createLibrary(library, 50, 50, 100);
        /* borrow a non-exists product */
        Set<Integer> productIds = my.products.stream().map(Product::getProductId).collect(Collectors.toSet());
        Map<Integer, Integer> stockMap = my.products.stream().collect(
                Collectors.toMap(Product::getProductId, Product::getSource));
        int nbId = RandomUtils.nextInt(0, 200);
        while (productIds.contains(nbId)) {
            nbId = RandomUtils.nextInt(0, 200);
        }
        Set<Integer> cardIds = my.cards.stream().map(Card::getCardId).collect(Collectors.toSet());
        Borrow nb = new Borrow(nbId, my.cards.get(0).getCardId());
        nb.resetBorrowTime();
        nb.resetReturnTime();
        Assert.assertFalse(library.borrowProduct(nb).ok);
        Assert.assertFalse(library.returnProduct(nb).ok);
        // card not exists
        int ncId = RandomUtils.nextInt(0, 200);
        while (cardIds.contains(ncId)) {
            ncId = RandomUtils.nextInt(0, 200);
        }
        Borrow nc = new Borrow(my.products.get(0).getProductId(), ncId);
        nc.resetBorrowTime();
        nc.resetReturnTime();
        Assert.assertFalse(library.borrowProduct(nc).ok);
        Assert.assertFalse(library.returnProduct(nc).ok);
        // product & card both not exist
        Borrow nbc = new Borrow(nbId, ncId);
        nbc.resetBorrowTime();
        Assert.assertFalse(library.borrowProduct(nbc).ok);
        /* borrow a product */
        Product b0 = my.products.get(RandomUtils.nextInt(0, my.nProducts()));
        Assert.assertTrue(b0.getSource() > 0);
        Card c0 = my.cards.get(RandomUtils.nextInt(0, my.nCards()));
        Borrow r0 = new Borrow(b0, c0);
        r0.resetBorrowTime();
        r0.resetReturnTime();
        Assert.assertFalse(library.returnProduct(r0).ok);
        Assert.assertTrue(library.borrowProduct(r0).ok);
        /* borrow it again */
        Borrow r1 = new Borrow(b0, c0);
        r1.resetBorrowTime();
        Assert.assertFalse(library.borrowProduct(r1).ok);
        /* return this product */
        // corner case, for return_time > borrow_time
        Borrow nt = new Borrow(b0, c0);
        nt.setReturnTime(666);
        Assert.assertFalse(library.returnProduct(nt).ok);
        nt.setReturnTime(r0.getBorrowTime());
        Assert.assertFalse(library.returnProduct(nt).ok);
        // normal case
        r0.resetReturnTime();
        Assert.assertTrue(library.returnProduct(r0).ok);
        my.borrows.add(r0);     // add to borrow list after operation
        /* return this product again */
        r1.resetReturnTime();
        Assert.assertFalse(library.returnProduct(r1).ok);
        /* borrow & return this product */
        Borrow r2 = new Borrow(b0, c0);
        r2.resetBorrowTime();
        Assert.assertTrue(library.borrowProduct(r2).ok);
        r2.resetReturnTime();
        Assert.assertTrue(library.returnProduct(r2).ok);
        my.borrows.add(r2);     // add to borrow list after operation
        /* try to borrow a zero-source product */
        Assert.assertTrue(library.incProductStock(b0.getProductId(), -b0.getSource()).ok);
        Borrow r3 = new Borrow(b0, c0);
        r3.resetBorrowTime();
        Assert.assertFalse(library.borrowProduct(r3).ok);
        stockMap.put(b0.getProductId(), 0);    // now b0.source == 0
        /* randomly borrow & return products */
        List<Borrow> borrowList = new ArrayList<>();
        Set<Pair<Integer, Integer>> borrowStatus = new HashSet<>();
        for (int i = 0; i < 1000; i++) {
            if (RandomUtils.nextBoolean() && borrowList.size() > 0) { // do return product
                int k = RandomUtils.nextInt(0, borrowList.size());
                Borrow r = borrowList.get(k);
                r.resetReturnTime();
                Pair<Integer, Integer> sp = new ImmutablePair<>(r.getProductId(), r.getCardId());
                Assert.assertTrue(library.returnProduct(r).ok);
                borrowList.remove(k);
                borrowStatus.remove(sp);
                my.borrows.add(r);    // add to borrow list after operation
                stockMap.put(r.getProductId(), stockMap.get(r.getProductId()) + 1);
            } else {    // do borrow product
                Product b = my.products.get(RandomUtils.nextInt(0, my.nProducts()));
                Card c = my.cards.get(RandomUtils.nextInt(0, my.nCards()));
                Borrow r = new Borrow(b, c);
                r.resetBorrowTime();
                Pair<Integer, Integer> sp = new ImmutablePair<>(b.getProductId(), c.getCardId());
                if (borrowStatus.contains(sp) || stockMap.get(r.getProductId()) == 0) {
                    Assert.assertFalse(library.borrowProduct(r).ok);
                } else {
                    Assert.assertTrue(library.borrowProduct(r).ok);
                    borrowStatus.add(sp);
                    borrowList.add(r);
                    stockMap.put(r.getProductId(), stockMap.get(r.getProductId()) - 1);
                }
            }
        }
        // add un-returned products to borrow histories
        my.borrows.addAll(borrowList);
        /* compare borrow histories */
        Map<Integer, Product> productMap = my.products.stream().collect(
                Collectors.toMap(Product::getProductId, v -> v));
        // card_id --> borrow_items
        Map<Integer, List<BorrowHistories.Item>> expectedBorrowMap = new HashMap<>();
        for (Borrow borrow : my.borrows) {
            BorrowHistories.Item item = new BorrowHistories.Item(borrow.getCardId(),
                    productMap.get(borrow.getProductId()), borrow);
            if (!expectedBorrowMap.containsKey(borrow.getCardId())) {
                expectedBorrowMap.put(borrow.getCardId(), new ArrayList<>());
            }
            expectedBorrowMap.get(borrow.getCardId()).add(item);
        }
        for (List<BorrowHistories.Item> list : expectedBorrowMap.values()) {
            list.sort((x, y) -> {
                if (x.getBorrowTime() == y.getBorrowTime()) {
                    return x.getProductId() - y.getProductId();
                }
                return x.getBorrowTime() < y.getBorrowTime() ? 1 : -1;
            });
        }
        for (Card card : my.cards) {
            ApiResult result = library.showBorrowHistory(card.getCardId());
            Assert.assertTrue(result.ok);
            BorrowHistories histories = (BorrowHistories) result.payload;
            List<BorrowHistories.Item> expectedList = expectedBorrowMap.get(card.getCardId());
            Assert.assertEquals(expectedList.size(), histories.getCount());
            for (int i = 0; i < expectedList.size(); i++) {
                BorrowHistories.Item o1 = expectedList.get(i);
                BorrowHistories.Item o2 = histories.getItems().get(i);
                Assert.assertEquals(o1.toString(), o2.toString());
            }
        }
    }

    @Test
    public void parallelBorrowProductTest() {
        int nThreads = BorrowThread.nThreads;
        MyLibrary my = MyLibrary.createLibrary(library, 1, nThreads, 0);
        Product product = my.products.get(0);
        // let product.source = 1
        Assert.assertTrue(library.incProductStock(product.getProductId(), -product.getSource() + 1).ok);
        /* all threads connect to database */
        List<DatabaseConnector> connectors = new ArrayList<>();
        List<LibraryManagementSystem> libraries = new ArrayList<>();
        for (int i = 0; i < nThreads; i++) {
            DatabaseConnector connector = new DatabaseConnector(connectConfig);
            Assert.assertTrue(connector.connect());
            connectors.add(connector);
            libraries.add(new LibraryManagementSystemImpl(connector));
        }
        /* start all threads */
        List<BorrowThread> borrowThreads = new ArrayList<>();
        BorrowThread.acquireAll();
        for (int i = 0; i < nThreads; i++) {
            Borrow borrow = new Borrow(product, my.cards.get(i));
            borrow.resetBorrowTime();
            BorrowThread thd = new BorrowThread(i, libraries.get(i), borrow);
            thd.start();
            borrowThreads.add(thd);
        }
        BorrowThread.releaseAll();
        /* wait all threads finish */
        for (int i = 0; i < nThreads; i++) {
            try {
                borrowThreads.get(i).join();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        /* check results */
        // only one thread can successfully borrow the product
        Assert.assertEquals(1, BorrowThread.successOps.get());
        /* release all connections */
        for (int i = 0; i < nThreads; i++) {
            Assert.assertTrue(connectors.get(i).release());
        }
    }

    @Test
    public void registerAndShowAndRemoveCardTest() {
        /* simply insert N cards */
        MyLibrary my = MyLibrary.createLibrary(library, 1, 100, 0);
        /* duplicate create */
        Card duplicateCard = my.cards.get(RandomUtils.nextInt(0, my.nCards())).clone();
        duplicateCard.setCardId(0);
        Assert.assertFalse(library.registerCard(duplicateCard).ok);
        /* delete a card that has some un-returned products */
        int delPos = RandomUtils.nextInt(0, my.nCards());
        Card delCard = my.cards.get(delPos);
        Borrow borrow = new Borrow(my.products.get(0), delCard);
        borrow.resetBorrowTime();
        Assert.assertTrue(library.borrowProduct(borrow).ok);
        Assert.assertFalse(library.removeCard(delCard.getCardId()).ok);
        borrow.resetReturnTime();
        Assert.assertTrue(library.returnProduct(borrow).ok);
        Assert.assertTrue(library.removeCard(delCard.getCardId()).ok);
        /* delete a non-exists card */
        Assert.assertFalse(library.removeCard(-1).ok);
        Assert.assertFalse(library.removeCard(delCard.getCardId()).ok);
        my.cards.remove(delPos);
        /* randomly delete some cards */
        Collections.shuffle(my.cards);
        for (int i = 0; i < 20; i++) {
            Card dCard = my.cards.get(0);
            Assert.assertTrue(library.removeCard(dCard.getCardId()).ok);
            Assert.assertFalse(library.removeCard(dCard.getCardId()).ok);
            my.cards.remove(0);
        }
        /* check cards */
        my.cards.sort(Comparator.comparingInt(Card::getCardId));
        ApiResult result = library.showCards();
        Assert.assertTrue(result.ok);
        CardList resCardList = (CardList) result.payload;
        Assert.assertEquals(my.nCards(), resCardList.getCount());
        for (int i = 0; i < my.nCards(); i++) {
            Card o1 = my.cards.get(i);
            Card o2 = resCardList.getCards().get(i);
            Assert.assertEquals(o1.toString(), o2.toString());
        }
    }

    private List<Product> verifyQueryResult(List<Product> products, ProductQueryConditions conditions) {
        Stream<Product> stream = products.stream();
        if (conditions.getComment() != null) {
            stream = stream.filter(b -> b.getComment().equals(conditions.getComment()));
        }
        if (conditions.getTitle() != null) {
            stream = stream.filter(b -> b.getTitle().contains(conditions.getTitle()));
        }
        if (conditions.getShop() != null) {
            stream = stream.filter(b -> b.getShop().contains(conditions.getShop()));
        }
//        if (conditions.getMinPublishYear() != null) {
//            stream = stream.filter(b -> b.getDeal() >= conditions.getMinPublishYear());
//        }
//        if (conditions.getMaxPublishYear() != null) {
//            stream = stream.filter(b -> b.getDeal() <= conditions.getMaxPublishYear());
//        }
        if (conditions.getImg() != null) {
            stream = stream.filter(b -> b.getImg().contains(conditions.getImg()));
        }
        if (conditions.getMinPrice() != null) {
            stream = stream.filter(b -> b.getPrice() >= conditions.getMinPrice());
        }
        if (conditions.getMaxPrice() != null) {
            stream = stream.filter(b -> b.getPrice() <= conditions.getMaxPrice());
        }
        Comparator<Product> cmp = conditions.getSortBy().getComparator();
        if (conditions.getSortOrder() == SortOrder.DESC) {
            cmp = cmp.reversed();
        }
        Comparator<Product> comparator = cmp;
        Comparator<Product> sortComparator = (lhs, rhs) -> {
            if (comparator.compare(lhs, rhs) == 0) {
                return lhs.getProductId() - rhs.getProductId();
            }
            return comparator.compare(lhs, rhs);
        };
        return stream.sorted(sortComparator).collect(Collectors.toList());

    }

}
